package sandeep_kumar_sahoo;

import java.util.*;
public class HashMapCode {
static class HashMap<K,V> { //generics,HashMap class to work with any data type for
	                 //keys (K) and values (V), instead of being restricted to a specific type.
	             //HashMap is static, it can be used without creating an instance of HashMapCode
private class Node {
K key;
V value;

public Node(K key, V value) {//constructor
	                  //âœ… Initialize in Node() â†’ If it applies to a single key-value pair (e.g., key, value).



this.key = key;
this.value = value;
}
}
private int n; //n - nodes
private int N; //N - buckets
private LinkedList<Node> buckets[]; //N = buckets.length,This declares an array named buckets,
                                 //where each element is of type LinkedList<Node>

@SuppressWarnings("unchecked")
public HashMap() {//constructor,we write N and bucket inside the Hashmap constructor 
	           //âœ… Initialize in HashMap() â†’  it applies to the entire HashMap (e.g., N, buckets[]).
this.N = 4;
this.buckets = new LinkedList[4];
for(int i=0; i<4; i++) {
this.buckets[i] = new LinkedList<>();//creates an array of size 4, which can store references to
                                     //  buckets[i] holds an empty linked list, ready to store key-value pairs
                                    //LinkedList<Node> objects.
// it also equivalent to -> LinkedList<Node>[] buckets = new LinkedList[4]; // Creates an array but doesn't initialize the lists

}
}

private int hashFunction(K key) {
int bi = key.hashCode();
return Math.abs(bi) % N;// hash code (generated by key.hashCode()).
                      //But hash codes can be very large, positive or negative integers like
                       //India".hashCode()  = 123456789
                        //"China".hashCode()  = 987654321
                     // As we have N no of buckets so if we do mod with N it gives reminder (0 to N-1)
                   //HashMap, keys are stored at random-looking indexes because their position 
                    //is determined by a hash function.
}

private int searchInLL(K key, int bi) {
LinkedList<Node> ll = buckets[bi];

for(int i=0; i<ll.size(); i++) {
if(ll.get(i).key == key) {
return i; //di
}
}

return -1;
}

@SuppressWarnings("unchecked")
private void rehash() {
LinkedList<Node> oldBucket[] = buckets;// we have stored all the buckets inside the oldBucket
buckets = new LinkedList[N*2];// now we increased the size by two
for(int i=0; i<N*2; i++) {
buckets[i] = new LinkedList<>();// we make the buckets empty before null was there
}
for(int i=0; i<oldBucket.length; i++) {//now we run loop for old bucket
LinkedList<Node> ll = oldBucket[i];//ll is a variable that refers to a LinkedList.
                                  //This LinkedList stores Node objects (key-value pairs).
                                  //So, ll can hold multiple Node objects.
                                 //oldBucket is an array of LinkedLists (LinkedList<Node>[]).
                                 //oldBucket[i] accesses the i-th LinkedList from the array
                            //Examples
                       //  oldBucket Index (i)      	LinkedList<Node> inside it
//                           0	                         (Empty)
//                           1	                         ("India", 190) â†’ ("China", 200)
//                           2                           	(Empty)
//                           3                          	("US", 50)
//

for(int j=0; j<ll.size(); j++) {
Node node = ll.get(j);//ll.get(j) fetches the jth Node (key-value pair) from that bucket.
                      // node is a variable that stores a reference to a Node object.
                      //It will hold one key-value pair from the LinkedList at a time
                      //Node node = ll.get(0); // node now holds ("India", 190)
           
                      //Node stores one key-value pair.
                        //âœ” ll stores multiple Nodes (key-value pairs) inside a bucket.
                     // Node node	Creates a variable node to store the retrieved Node from the LinkedList.


//buckets[0] â†’ [ Node("India", 190) â†’ Node("China", 200) ]      (LinkedList of Nodes)
//buckets[1] â†’ [ Node("US", 50) ]                                (LinkedList of Nodes)
//buckets[2] â†’ [ ]  (empty)
//buckets[3] â†’ [ ]  (empty)


//ðŸ”¹ Step-by-Step Execution
//1ï¸âƒ£ Iteration 1: i = 0 (Processing buckets[0])
//
//ll = oldBucket[0] â†’ [ Node("India", 190) â†’ Node("China", 200) ]
//Inner loop runs for ll.size() = 2:
//j = 0: Fetch Node("India", 190), call put("India", 190)
//j = 1: Fetch Node("China", 200), call put("China", 200)
//2ï¸âƒ£ Iteration 2: i = 1 (Processing buckets[1])
//
//ll = oldBucket[1] â†’ [ Node("US", 50) ]
//Inner loop runs for ll.size() = 1:
//j = 0: Fetch Node("US", 50), call put("US", 50)
//Since each bucket is processed sequentially, after finishing buckets[0], we move to buckets[1], where "US" is stored. Thatâ€™s how we reach "US".






put(node.key, node.value);//it will call put function
}
}
}

public void put(K key, V value) {
int bi = hashFunction(key);
int di = searchInLL(key, bi); //di = -1
if(di == -1) { //key doesn't exist
buckets[bi].add(new Node(key, value));
n++;
} else { //key exists
Node node = buckets[bi].get(di);
node.value = value;
}
double lambda = (double)n/N;

if(lambda > 2.0) {
rehash();
}
}

public boolean containsKey(K key) {
int bi = hashFunction(key);
int di = searchInLL(key, bi); //di = -1
if(di == -1) { //key doesn't exist
return false;
} else { //key exists
return true;
}
}

public V remove(K key) {
int bi = hashFunction(key);
int di = searchInLL(key, bi); //di = -1
if(di == -1) { //key doesn't exist
return null;
} else { //key exists
Node node = buckets[bi].remove(di);
n--;
return node.value;
}
}

public V get(K key) {
int bi = hashFunction(key);
int di = searchInLL(key, bi); //di = -1
if(di == -1) { //key doesn't exist
return null;
} else { //key exists
Node node = buckets[bi].get(di);
return node.value;
}
}

public ArrayList<K> keySet() {
ArrayList<K> keys = new ArrayList<>();
for(int i=0; i<buckets.length; i++) { //bi
LinkedList<Node> ll = buckets[i];
for(int j=0; j<ll.size(); j++) { //di
Node node = ll.get(j);
keys.add(node.key);
}
}
return keys;
}
public boolean isEmpty() {
return n == 0;
}
}
public static void main(String args[]) {
HashMap<String, Integer> map = new HashMap<>();
map.put("India", 190);
map.put("China", 200);
map.put("US", 50);
ArrayList<String> keys = map.keySet();
for(int i=0; i<keys.size(); i++) {
System.out.println(keys.get(i)+" "+map.get(keys.get(i)));
}

map.remove("India");
System.out.println(map.get("India"));
}
}

//
//Example with Step-by-Step Index Calculation
//Let's assume N = 4 (4 buckets initially) and we insert the following key-value pairs:
//

//map.put("India", 190);
//map.put("China", 200);
//map.put("US", 50);
//map.put("Canada", 80);
//map.put("Germany", 120);
//map.put("Australia", 60);
//Now, suppose the .hashCode() values of these keys (just an example) are:
//
//Key	hashCode()	Bucket Index (bi = abs(hashCode) % N)
//"India"	12345	12345 % 4 = 1
//"China"	67890	67890 % 4 = 2
//"US"	54321	54321 % 4 = 1
//"Canada"	13579	13579 % 4 = 3
//"Germany"	24680	24680 % 4 = 0
//"Australia"	86420	86420 % 4 = 0
//Final HashMap (Before Rehashing)
//Bucket Index (bi)	Stored Key-Value Pairs (Linked List)
//0	("Germany", 120) â†’ ("Australia", 60)
//1	("India", 190) â†’ ("US", 50)
//2	("China", 200)
//3	("Canada", 80)
//




//buckets[0] â†’ [ Node("India", 190) â†’ Node("China", 200) ]  (LinkedList of Nodes)
//buckets[1] â†’ [ Node("US", 50) ]                            (LinkedList of Nodes)
//buckets[2] â†’ [ ]  (empty)
//buckets[3] â†’ [ ]  (empty)
//
